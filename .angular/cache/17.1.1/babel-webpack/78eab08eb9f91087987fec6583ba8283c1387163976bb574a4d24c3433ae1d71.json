{"ast":null,"code":"import { Subject, fromEvent } from 'rxjs';\nimport * as i3 from '@angular/cdk/portal';\nimport { CdkPortalOutlet, ComponentPortal, TemplatePortal, PortalModule } from '@angular/cdk/portal';\nimport * as i0 from '@angular/core';\nimport { Component, ChangeDetectionStrategy, Inject, ViewChild, HostBinding, HostListener, TemplateRef, Injector, Injectable, NgModule } from '@angular/core';\nimport { filter, takeUntil, take } from 'rxjs/operators';\nimport * as i2 from '@angular/common';\nimport { DOCUMENT, CommonModule } from '@angular/common';\nimport * as i1 from '@angular/cdk/a11y';\nimport * as i1$1 from '@angular/cdk/overlay';\nimport { OverlayConfig, OverlayModule } from '@angular/cdk/overlay';\n\n/* eslint-disable @typescript-eslint/no-inferrable-types */\nconst _c0 = [\"dialog\"];\nconst _c1 = [\"content\"];\nfunction MdbModalContainerComponent_ng_template_4_Template(rf, ctx) {}\nconst _c2 = a0 => ({\n  \"rounded-0\": a0\n});\nclass MdbModalConfig {\n  animation = true;\n  backdrop = true;\n  ignoreBackdropClick = false;\n  keyboard = true;\n  modalClass = '';\n  containerClass = '';\n  viewContainerRef;\n  data = null;\n  nonInvasive = false;\n}\nclass MdbModalRef {\n  _overlayRef;\n  _container;\n  constructor(_overlayRef, _container) {\n    this._overlayRef = _overlayRef;\n    this._container = _container;\n  }\n  component;\n  onClose$ = new Subject();\n  onClose = this.onClose$.asObservable();\n  close(message) {\n    this._container._close();\n    setTimeout(() => {\n      if (this._container._config.nonInvasive) {\n        this._container._onNonInvasiveModalHidden();\n      }\n      this._container._restoreScrollbar();\n      this.onClose$.next(message);\n      this.onClose$.complete();\n      this._overlayRef.detach();\n      this._overlayRef.dispose();\n    }, this._container.MODAL_TRANSITION);\n  }\n}\n\n// width below which, according to css rules, modal position changes - modal gets position relative instead of absolute.\nconst MODAL_CSS_BREAKPOINT = 992;\nconst MODAL_OPEN_CLASS = 'modal-open';\nconst NON_INVASIVE_CLASS = 'modal-non-invasive-open';\nconst NON_INVASIVE_SHOW_CLASS = 'modal-non-invasive-show';\nlet MdbModalContainerComponent = /*#__PURE__*/(() => {\n  class MdbModalContainerComponent {\n    _document;\n    _elementRef;\n    _renderer;\n    _focusTrapFactory;\n    _ngZone;\n    _portalOutlet;\n    modalDialog;\n    modalContent;\n    _destroy$ = new Subject();\n    backdropClick$ = new Subject();\n    _config;\n    BACKDROP_TRANSITION = 150;\n    MODAL_TRANSITION = 200;\n    NON_INVASIVE_TRANSITION = 450;\n    _previouslyFocusedElement;\n    _focusTrap;\n    modal = true;\n    get hasAnimation() {\n      return this._config.animation;\n    }\n    onWindowResize() {\n      this._ngZone.runOutsideAngular(() => {\n        if (this._config.nonInvasive) {\n          this._handleWindowResize();\n        }\n      });\n    }\n    get host() {\n      return this._elementRef.nativeElement;\n    }\n    _isScrollable = false;\n    _isBottomRight = false;\n    _isBottomLeft = false;\n    _isTopRight = false;\n    _isTopLeft = false;\n    _isSideTopModal = false;\n    _isSideBottomModal = false;\n    _isSideModal = false;\n    _isModalBottom = false;\n    _modalContentRect;\n    _modalContentComputedStyles;\n    _modalDialogComputedStyles;\n    _topOffset = 0;\n    _leftOffset = 0;\n    _rightOffset = 0;\n    _bottomOffset = 0;\n    constructor(_document, _elementRef, _renderer, _focusTrapFactory, _ngZone) {\n      this._document = _document;\n      this._elementRef = _elementRef;\n      this._renderer = _renderer;\n      this._focusTrapFactory = _focusTrapFactory;\n      this._ngZone = _ngZone;\n    }\n    ngOnInit() {\n      this._updateContainerClass();\n      this._renderer.setStyle(this.host, 'display', 'block');\n      if (!this._config.nonInvasive) {\n        this._focusTrap = this._focusTrapFactory.create(this.host);\n        this._previouslyFocusedElement = this._document.activeElement;\n      }\n      if (this._config.animation) {\n        setTimeout(() => {\n          this._renderer.addClass(this.host, 'show');\n          setTimeout(() => {\n            this._focusTrap?.focusInitialElementWhenReady();\n          }, this.MODAL_TRANSITION);\n        }, this.BACKDROP_TRANSITION);\n      } else {\n        this._focusTrap?.focusInitialElementWhenReady();\n      }\n    }\n    ngAfterViewInit() {\n      const widthWithVerticalScroll = this._document.body.offsetWidth;\n      this._renderer.addClass(this._document.body, MODAL_OPEN_CLASS);\n      if (this._config.nonInvasive) {\n        this._renderer.addClass(this._document.body, NON_INVASIVE_CLASS);\n        setTimeout(() => {\n          this._onNonInvasiveModalShown();\n        }, this.NON_INVASIVE_TRANSITION);\n      }\n      if (!this._config.nonInvasive) {\n        this._renderer.setStyle(this._document.body, 'overflow', 'hidden');\n      }\n      const widthWithoutVerticalScroll = this._document.body.offsetWidth;\n      if (!this._config.nonInvasive) {\n        this._renderer.setStyle(this._document.body, 'padding-right', `${widthWithoutVerticalScroll - widthWithVerticalScroll}px`);\n      }\n      if (!this._config.ignoreBackdropClick && !this._config.nonInvasive) {\n        fromEvent(this.host, 'mousedown').pipe(filter(event => {\n          const target = event.target;\n          const dialog = this.modalDialog.nativeElement;\n          const notDialog = target !== dialog;\n          const notDialogContent = !dialog.contains(target);\n          return notDialog && notDialogContent;\n        }), takeUntil(this._destroy$)).subscribe(event => {\n          this.backdropClick$.next(event);\n        });\n      }\n    }\n    ngOnDestroy() {\n      this._previouslyFocusedElement?.focus();\n      this._focusTrap?.destroy();\n      this._destroy$.next();\n      this._destroy$.complete();\n    }\n    _updateContainerClass() {\n      if (this._config.containerClass === '' || this._config.containerClass.length && this._config.containerClass.length === 0) {\n        return;\n      }\n      const containerClasses = this._config.containerClass.split(' ');\n      containerClasses.forEach(containerClass => {\n        this._renderer.addClass(this.host, containerClass);\n      });\n    }\n    _onNonInvasiveModalShown() {\n      this._isScrollable = this._config.modalClass.includes('modal-dialog-scrollable');\n      this._isBottomRight = this._config.modalClass.includes('modal-bottom-right');\n      this._isBottomLeft = this._config.modalClass.includes('modal-bottom-left');\n      this._isTopRight = this._config.modalClass.includes('modal-top-right');\n      this._isTopLeft = this._config.modalClass.includes('modal-top-left');\n      this._isModalBottom = this._config.modalClass.includes('modal-bottom');\n      this._isSideTopModal = this._isTopLeft || this._isTopRight;\n      this._isSideBottomModal = this._isBottomLeft || this._isBottomRight;\n      this._isSideModal = this._isSideTopModal || this._isSideBottomModal;\n      this._modalContentRect = this.modalContent.nativeElement.getBoundingClientRect();\n      this._modalContentComputedStyles = window.getComputedStyle(this.modalContent.nativeElement);\n      this._modalDialogComputedStyles = window.getComputedStyle(this.modalDialog.nativeElement);\n      this._topOffset = parseInt(this._modalDialogComputedStyles.top, 0);\n      this._leftOffset = parseInt(this._modalDialogComputedStyles.left, 0);\n      this._rightOffset = parseInt(this._modalDialogComputedStyles.right, 0);\n      this._bottomOffset = parseInt(this._modalDialogComputedStyles.bottom, 0);\n      this._renderer.addClass(this.host, NON_INVASIVE_SHOW_CLASS);\n      this._setNonInvasiveStyles();\n    }\n    _setNonInvasiveStyles(leftOffset = 0, topOffset = 0) {\n      const isAboveBreakpoint = window.innerWidth >= MODAL_CSS_BREAKPOINT;\n      this._renderer.setStyle(this.host, 'left', `${this._modalContentRect.left + leftOffset}px`);\n      this._renderer.setStyle(this.host, 'width', this._modalContentComputedStyles.width);\n      if (!this._isScrollable) {\n        // If the modal content is not long enough to require scroll shrink the modal wrapper to\n        // the height of modal content so other elements on site are clickable outside modal\n        this._renderer.setStyle(this.host, 'height', this._modalContentComputedStyles.height);\n        this._renderer.setStyle(this.host, 'display', '');\n      }\n      if (isAboveBreakpoint) {\n        if (this._isSideBottomModal || this._isModalBottom) {\n          // Force modal to correct bottom placement. It's needed because modal host has position\n          // fixed and fixed height.\n          this._renderer.setStyle(this.host, 'top', `${this._modalContentRect.top + topOffset}px`);\n        }\n        if (this._isSideModal) {\n          // Enable horizontal scrolling when the content is wider than the modal's fixed width\n          this._renderer.setStyle(this.host, 'overflowX', 'auto');\n        }\n      }\n      if (!isAboveBreakpoint) {\n        this.host.style.height = '';\n      }\n    }\n    _onNonInvasiveModalHidden() {\n      this._renderer.removeClass(this.host, NON_INVASIVE_SHOW_CLASS);\n      this._resetNonInvasiveStyles();\n      this._removeNonInvasiveClass();\n    }\n    _resetNonInvasiveStyles() {\n      this._renderer.setStyle(this.host, 'left', '');\n      this._renderer.setStyle(this.host, 'top', '');\n      this._renderer.setStyle(this.host, 'height', '');\n      this._renderer.setStyle(this.host, 'width', '');\n      if (!this._isScrollable) {\n        this._renderer.setStyle(this.host, 'display', '');\n      }\n      if (this._isSideModal) {\n        this._renderer.setStyle(this.host, 'overflowX', '');\n      }\n    }\n    _removeNonInvasiveClass() {\n      const isOtherModalOpen = this._document.body.querySelector('.modal.show.modal-non-invasive-show');\n      if (!isOtherModalOpen) {\n        this._renderer.removeClass(this._document.body, NON_INVASIVE_CLASS);\n      } else {\n        this._renderer.addClass(this._document.body, MODAL_OPEN_CLASS);\n      }\n    }\n    _handleWindowResize() {\n      const modalContent = this.host.querySelector('.modal-content');\n      this._resetNonInvasiveStyles();\n      this._modalContentRect = modalContent.getBoundingClientRect();\n      this._modalContentComputedStyles = window.getComputedStyle(modalContent);\n      if (this._isSideTopModal || this._isSideBottomModal) {\n        let sideOffset = 0;\n        let topOffset = 0;\n        if (this._isBottomRight || this._isBottomLeft) {\n          topOffset = -this._bottomOffset;\n        }\n        if (this._isBottomRight || this._isTopRight) {\n          sideOffset = -this._rightOffset;\n        }\n        if (this._isBottomLeft || this._isTopLeft) {\n          sideOffset = this._leftOffset;\n        }\n        this._setNonInvasiveStyles(sideOffset, topOffset);\n      } else {\n        this._setNonInvasiveStyles();\n      }\n    }\n    _close() {\n      if (this._config.animation) {\n        this._renderer.removeClass(this.host, 'show');\n      }\n      // Pause iframe/video when closing modal\n      const iframeElements = Array.from(this.host.querySelectorAll('iframe'));\n      const videoElements = Array.from(this.host.querySelectorAll('video'));\n      iframeElements.forEach(iframe => {\n        const srcAttribute = iframe.getAttribute('src');\n        this._renderer.setAttribute(iframe, 'src', srcAttribute);\n      });\n      videoElements.forEach(video => {\n        video.pause();\n      });\n    }\n    _restoreScrollbar() {\n      this._renderer.removeClass(this._document.body, MODAL_OPEN_CLASS);\n      this._renderer.removeStyle(this._document.body, 'overflow');\n      this._renderer.removeStyle(this._document.body, 'padding-right');\n    }\n    attachComponentPortal(portal) {\n      return this._portalOutlet.attachComponentPortal(portal);\n    }\n    attachTemplatePortal(portal) {\n      return this._portalOutlet.attachTemplatePortal(portal);\n    }\n    static ɵfac = function MdbModalContainerComponent_Factory(t) {\n      return new (t || MdbModalContainerComponent)(i0.ɵɵdirectiveInject(DOCUMENT), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i1.ConfigurableFocusTrapFactory), i0.ɵɵdirectiveInject(i0.NgZone));\n    };\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: MdbModalContainerComponent,\n      selectors: [[\"mdb-modal-container\"]],\n      viewQuery: function MdbModalContainerComponent_Query(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵviewQuery(CdkPortalOutlet, 7);\n          i0.ɵɵviewQuery(_c0, 7);\n          i0.ɵɵviewQuery(_c1, 7);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._portalOutlet = _t.first);\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.modalDialog = _t.first);\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.modalContent = _t.first);\n        }\n      },\n      hostVars: 4,\n      hostBindings: function MdbModalContainerComponent_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵlistener(\"resize\", function MdbModalContainerComponent_resize_HostBindingHandler($event) {\n            return ctx.onWindowResize($event);\n          }, false, i0.ɵɵresolveWindow);\n        }\n        if (rf & 2) {\n          i0.ɵɵclassProp(\"modal\", ctx.modal)(\"fade\", ctx.hasAnimation);\n        }\n      },\n      decls: 5,\n      vars: 5,\n      consts: [[\"dialog\", \"\"], [1, \"modal-content\", 3, \"ngClass\"], [\"content\", \"\"], [\"cdkPortalOutlet\", \"\"]],\n      template: function MdbModalContainerComponent_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵelementStart(0, \"div\", null, 0)(2, \"div\", 1, 2);\n          i0.ɵɵtemplate(4, MdbModalContainerComponent_ng_template_4_Template, 0, 0, \"ng-template\", 3);\n          i0.ɵɵelementEnd()();\n        }\n        if (rf & 2) {\n          i0.ɵɵclassMap(\"modal-dialog\" + (ctx._config.modalClass ? \" \" + ctx._config.modalClass : \"\"));\n          i0.ɵɵadvance(2);\n          i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction1(3, _c2, ctx._config.modalClass.includes(\"modal-frame\")));\n        }\n      },\n      dependencies: [i2.NgClass, i3.CdkPortalOutlet],\n      encapsulation: 2\n    });\n  }\n  return MdbModalContainerComponent;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet MdbModalService = /*#__PURE__*/(() => {\n  class MdbModalService {\n    _document;\n    _overlay;\n    _injector;\n    _cfr;\n    constructor(_document, _overlay, _injector, _cfr) {\n      this._document = _document;\n      this._overlay = _overlay;\n      this._injector = _injector;\n      this._cfr = _cfr;\n    }\n    open(componentOrTemplateRef, config) {\n      const defaultConfig = new MdbModalConfig();\n      config = config ? Object.assign(defaultConfig, config) : defaultConfig;\n      const overlayRef = this._createOverlay(config);\n      const container = this._createContainer(overlayRef, config);\n      const modalRef = this._createContent(componentOrTemplateRef, container, overlayRef, config);\n      this._registerListeners(modalRef, config, container);\n      return modalRef;\n    }\n    _createOverlay(config) {\n      const overlayConfig = this._getOverlayConfig(config);\n      return this._overlay.create(overlayConfig);\n    }\n    _getOverlayConfig(modalConfig) {\n      const config = new OverlayConfig({\n        positionStrategy: this._overlay.position().global(),\n        scrollStrategy: this._overlay.scrollStrategies.noop(),\n        hasBackdrop: modalConfig.nonInvasive ? false : modalConfig.backdrop,\n        backdropClass: 'mdb-backdrop'\n      });\n      return config;\n    }\n    _createContainer(overlayRef, config) {\n      const portal = new ComponentPortal(MdbModalContainerComponent, null, this._injector, this._cfr);\n      const containerRef = overlayRef.attach(portal);\n      containerRef.instance._config = config;\n      return containerRef.instance;\n    }\n    _createContent(componentOrTemplate, container, overlayRef, config) {\n      const modalRef = new MdbModalRef(overlayRef, container);\n      if (componentOrTemplate instanceof TemplateRef) {\n        container.attachTemplatePortal(new TemplatePortal(componentOrTemplate, null, {\n          $implicit: config.data,\n          modalRef\n        }));\n      } else {\n        const injector = this._createInjector(config, modalRef, container);\n        const contentRef = container.attachComponentPortal(new ComponentPortal(componentOrTemplate, config.viewContainerRef, injector));\n        if (config.data) {\n          Object.assign(contentRef.instance, {\n            ...config.data\n          });\n        }\n        modalRef.component = contentRef.instance;\n      }\n      return modalRef;\n    }\n    _createInjector(config, modalRef, container) {\n      const userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;\n      // The dialog container should be provided as the dialog container and the dialog's\n      // content are created out of the same `ViewContainerRef` and as such, are siblings\n      // for injector purposes. To allow the hierarchy that is expected, the dialog\n      // container is explicitly provided in the injector.\n      const providers = [{\n        provide: MdbModalContainerComponent,\n        useValue: container\n      }, {\n        provide: MdbModalRef,\n        useValue: modalRef\n      }];\n      return Injector.create({\n        parent: userInjector || this._injector,\n        providers\n      });\n    }\n    _registerListeners(modalRef, config, container) {\n      container.backdropClick$.pipe(take(1)).subscribe(() => {\n        modalRef.close();\n      });\n      if (config.keyboard) {\n        fromEvent(container._elementRef.nativeElement, 'keydown').pipe(filter(event => {\n          return event.key === 'Escape';\n        }), take(1)).subscribe(() => {\n          modalRef.close();\n        });\n      }\n    }\n    static ɵfac = function MdbModalService_Factory(t) {\n      return new (t || MdbModalService)(i0.ɵɵinject(DOCUMENT), i0.ɵɵinject(i1$1.Overlay), i0.ɵɵinject(i0.Injector), i0.ɵɵinject(i0.ComponentFactoryResolver));\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: MdbModalService,\n      factory: MdbModalService.ɵfac\n    });\n  }\n  return MdbModalService;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet MdbModalModule = /*#__PURE__*/(() => {\n  class MdbModalModule {\n    static ɵfac = function MdbModalModule_Factory(t) {\n      return new (t || MdbModalModule)();\n    };\n    static ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: MdbModalModule\n    });\n    static ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n      providers: [MdbModalService],\n      imports: [CommonModule, OverlayModule, PortalModule]\n    });\n  }\n  return MdbModalModule;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { MdbModalConfig, MdbModalContainerComponent, MdbModalModule, MdbModalRef, MdbModalService };\n//# sourceMappingURL=mdb-angular-ui-kit-modal.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}