{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { Directive, ElementRef, Component, ChangeDetectionStrategy, ViewChild, ContentChild, HostBinding, Optional, Self, Input, HostListener, NgModule } from '@angular/core';\nimport { Subject } from 'rxjs';\nimport { takeUntil } from 'rxjs/operators';\nimport * as i1 from '@angular/cdk/observers';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport * as i1$1 from '@angular/forms';\nimport { FormsModule } from '@angular/forms';\nimport * as i2 from '@angular/cdk/text-field';\nimport { CommonModule } from '@angular/common';\n\n// eslint-disable-next-line @angular-eslint/directive-class-suffix\nconst _c0 = [\"notchLeading\"];\nconst _c1 = [\"notchMiddle\"];\nconst _c2 = [\"*\"];\nlet MdbAbstractFormControl = /*#__PURE__*/(() => {\n  class MdbAbstractFormControl {\n    stateChanges;\n    input;\n    labelActive;\n    static ɵfac = function MdbAbstractFormControl_Factory(t) {\n      return new (t || MdbAbstractFormControl)();\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: MdbAbstractFormControl\n    });\n  }\n  return MdbAbstractFormControl;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n// eslint-disable-next-line @angular-eslint/component-class-suffix\nlet MdbLabelDirective = /*#__PURE__*/(() => {\n  class MdbLabelDirective {\n    constructor() {}\n    static ɵfac = function MdbLabelDirective_Factory(t) {\n      return new (t || MdbLabelDirective)();\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: MdbLabelDirective,\n      selectors: [[\"\", \"mdbLabel\", \"\"]],\n      exportAs: [\"mdbLabel\"]\n    });\n  }\n  return MdbLabelDirective;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet MdbFormControlComponent = /*#__PURE__*/(() => {\n  class MdbFormControlComponent {\n    _renderer;\n    _contentObserver;\n    _elementRef;\n    _ngZone;\n    _notchLeading;\n    _notchMiddle;\n    _formControl;\n    _label;\n    outline = true;\n    display = true;\n    get input() {\n      return this._formControl.input;\n    }\n    constructor(_renderer, _contentObserver, _elementRef, _ngZone) {\n      this._renderer = _renderer;\n      this._contentObserver = _contentObserver;\n      this._elementRef = _elementRef;\n      this._ngZone = _ngZone;\n    }\n    _destroy$ = new Subject();\n    _notchLeadingLength = 9;\n    _labelMarginLeft = 0;\n    _labelGapPadding = 8;\n    _labelScale = 0.8;\n    _recalculateGapWhenVisible = false;\n    ngAfterContentInit() {\n      if (this._label) {\n        setTimeout(() => {\n          this._updateBorderGap();\n        }, 0);\n      } else {\n        this._renderer.addClass(this.input, 'placeholder-active');\n      }\n      this._updateLabelActiveState();\n      if (this._label) {\n        this._contentObserver.observe(this._label.nativeElement).pipe(takeUntil(this._destroy$)).subscribe(() => {\n          this._updateBorderGap();\n        });\n      }\n      this._formControl.stateChanges.pipe(takeUntil(this._destroy$)).subscribe(() => {\n        this._updateLabelActiveState();\n        if (this._label) {\n          this._updateBorderGap();\n        }\n      });\n      this._ngZone.runOutsideAngular(() => {\n        this._ngZone.onStable.pipe(takeUntil(this._destroy$)).subscribe(() => {\n          if (this._label && this._recalculateGapWhenVisible) {\n            this._updateBorderGap();\n          }\n        });\n      });\n    }\n    ngOnDestroy() {\n      this._destroy$.next();\n      this._destroy$.unsubscribe();\n    }\n    _getLabelWidth() {\n      return this._label.nativeElement.clientWidth * this._labelScale + this._labelGapPadding;\n    }\n    _updateBorderGap() {\n      // Element is in DOM but is not visible, we need to recalculate the gap when element\n      // is displayed. This problem may occur in components such as tabs where content of\n      // inactive tabs has display:none styles\n      if (this._isHidden()) {\n        this._recalculateGapWhenVisible = true;\n        return;\n      }\n      const notchLeadingWidth = `${this._labelMarginLeft + this._notchLeadingLength}px`;\n      const notchMiddleWidth = `${this._getLabelWidth()}px`;\n      this._notchLeading.nativeElement.style.width = notchLeadingWidth;\n      this._notchMiddle.nativeElement.style.width = notchMiddleWidth;\n      this._label.nativeElement.style.marginLeft = `${this._labelMarginLeft}px`;\n      this._recalculateGapWhenVisible = false;\n    }\n    _updateLabelActiveState() {\n      if (this._isLabelActive()) {\n        this._renderer.addClass(this.input, 'active');\n      } else {\n        this._renderer.removeClass(this.input, 'active');\n      }\n    }\n    _isLabelActive() {\n      return this._formControl && this._formControl.labelActive;\n    }\n    _isHidden() {\n      const el = this._elementRef.nativeElement;\n      return !el.offsetHeight && !el.offsetWidth;\n    }\n    static ɵfac = function MdbFormControlComponent_Factory(t) {\n      return new (t || MdbFormControlComponent)(i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i1.ContentObserver), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n    };\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: MdbFormControlComponent,\n      selectors: [[\"mdb-form-control\"]],\n      contentQueries: function MdbFormControlComponent_ContentQueries(rf, ctx, dirIndex) {\n        if (rf & 1) {\n          i0.ɵɵcontentQuery(dirIndex, MdbAbstractFormControl, 7);\n          i0.ɵɵcontentQuery(dirIndex, MdbLabelDirective, 7, ElementRef);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._formControl = _t.first);\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._label = _t.first);\n        }\n      },\n      viewQuery: function MdbFormControlComponent_Query(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵviewQuery(_c0, 7);\n          i0.ɵɵviewQuery(_c1, 7);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._notchLeading = _t.first);\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._notchMiddle = _t.first);\n        }\n      },\n      hostVars: 4,\n      hostBindings: function MdbFormControlComponent_HostBindings(rf, ctx) {\n        if (rf & 2) {\n          i0.ɵɵclassProp(\"form-outline\", ctx.outline)(\"d-block\", ctx.display);\n        }\n      },\n      ngContentSelectors: _c2,\n      decls: 7,\n      vars: 0,\n      consts: [[1, \"form-notch\"], [1, \"form-notch-leading\"], [\"notchLeading\", \"\"], [1, \"form-notch-middle\"], [\"notchMiddle\", \"\"], [1, \"form-notch-trailing\"]],\n      template: function MdbFormControlComponent_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n          i0.ɵɵelementStart(1, \"div\", 0);\n          i0.ɵɵelement(2, \"div\", 1, 2)(4, \"div\", 3, 4)(6, \"div\", 5);\n          i0.ɵɵelementEnd();\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  }\n  return MdbFormControlComponent;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n// eslint-disable-next-line @angular-eslint/component-class-suffix\nlet MdbInputDirective = /*#__PURE__*/(() => {\n  class MdbInputDirective {\n    _elementRef;\n    _renderer;\n    _ngControl;\n    _autofill;\n    constructor(_elementRef, _renderer, _ngControl, _autofill) {\n      this._elementRef = _elementRef;\n      this._renderer = _renderer;\n      this._ngControl = _ngControl;\n      this._autofill = _autofill;\n    }\n    stateChanges = new Subject();\n    _focused = false;\n    _autofilled = false;\n    _color = '';\n    ngAfterViewInit() {\n      if (typeof getComputedStyle === 'function') {\n        this._color = getComputedStyle(this._elementRef.nativeElement).color;\n        if (this._hasTypeInterferingPlaceholder()) {\n          this._updateTextColorForDateType();\n        }\n      }\n      this._autofill.monitor(this.input).subscribe(event => {\n        this._autofilled = event.isAutofilled;\n        this.stateChanges.next();\n      });\n    }\n    _currentNativeValue;\n    get disabled() {\n      if (this._ngControl && this._ngControl.disabled !== null) {\n        return this._ngControl.disabled;\n      }\n      return this._disabled;\n    }\n    set disabled(value) {\n      this._disabled = coerceBooleanProperty(value);\n    }\n    _disabled = false;\n    get readonly() {\n      return this._readonly;\n    }\n    set readonly(value) {\n      if (value) {\n        this._renderer.setAttribute(this._elementRef.nativeElement, 'readonly', '');\n      } else {\n        this._renderer.removeAttribute(this._elementRef.nativeElement, 'readonly');\n      }\n      this._readonly = coerceBooleanProperty(value);\n    }\n    _readonly = false;\n    get value() {\n      return this._elementRef.nativeElement.value;\n    }\n    set value(value) {\n      if (value !== this.value) {\n        this._elementRef.nativeElement.value = value;\n        this._value = value;\n        this.stateChanges.next();\n      }\n    }\n    _value;\n    _updateTextColorForDateType() {\n      const actualColor = getComputedStyle(this._elementRef.nativeElement).color;\n      this._color = actualColor !== 'rgba(0, 0, 0, 0)' ? actualColor : this._color;\n      const color = this.labelActive ? this._color : `transparent`;\n      this._renderer.setStyle(this._elementRef.nativeElement, 'color', color);\n    }\n    _onFocus() {\n      this._focused = true;\n      if (this._hasTypeInterferingPlaceholder()) {\n        this._updateTextColorForDateType();\n      }\n      this.stateChanges.next();\n    }\n    _onBlur() {\n      this._focused = false;\n      if (this._hasTypeInterferingPlaceholder()) {\n        this._updateTextColorForDateType();\n      }\n      this.stateChanges.next();\n    }\n    ngDoCheck() {\n      const value = this._elementRef.nativeElement.value;\n      if (this._currentNativeValue !== value) {\n        this._currentNativeValue = value;\n        this.stateChanges.next();\n      }\n    }\n    get hasValue() {\n      return this._elementRef.nativeElement.value !== '';\n    }\n    get focused() {\n      return this._focused;\n    }\n    get autofilled() {\n      return this._autofilled;\n    }\n    get input() {\n      return this._elementRef.nativeElement;\n    }\n    get labelActive() {\n      return this.focused || this.hasValue || this.autofilled;\n    }\n    _hasTypeInterferingPlaceholder() {\n      const typesArray = ['date', 'datetime-local', 'time', 'month', 'week'];\n      return typesArray.includes(this._elementRef.nativeElement.type);\n    }\n    static ngAcceptInputType_disabled;\n    static ngAcceptInputType_readonly;\n    ngOnDestroy() {\n      this._autofill.stopMonitoring(this.input);\n    }\n    static ɵfac = function MdbInputDirective_Factory(t) {\n      return new (t || MdbInputDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i1$1.NgControl, 10), i0.ɵɵdirectiveInject(i2.AutofillMonitor));\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: MdbInputDirective,\n      selectors: [[\"\", \"mdbInput\", \"\"]],\n      hostVars: 1,\n      hostBindings: function MdbInputDirective_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵlistener(\"focus\", function MdbInputDirective_focus_HostBindingHandler() {\n            return ctx._onFocus();\n          })(\"blur\", function MdbInputDirective_blur_HostBindingHandler() {\n            return ctx._onBlur();\n          });\n        }\n        if (rf & 2) {\n          i0.ɵɵhostProperty(\"disabled\", ctx.disabled);\n        }\n      },\n      inputs: {\n        disabled: \"disabled\",\n        readonly: \"readonly\",\n        value: \"value\"\n      },\n      exportAs: [\"mdbInput\"],\n      features: [i0.ɵɵProvidersFeature([{\n        provide: MdbAbstractFormControl,\n        useExisting: MdbInputDirective\n      }])]\n    });\n  }\n  return MdbInputDirective;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet MdbFormsModule = /*#__PURE__*/(() => {\n  class MdbFormsModule {\n    static ɵfac = function MdbFormsModule_Factory(t) {\n      return new (t || MdbFormsModule)();\n    };\n    static ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: MdbFormsModule\n    });\n    static ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n      imports: [CommonModule, FormsModule]\n    });\n  }\n  return MdbFormsModule;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { MdbAbstractFormControl, MdbFormControlComponent, MdbFormsModule, MdbInputDirective, MdbLabelDirective };\n//# sourceMappingURL=mdb-angular-ui-kit-forms.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}